#재귀호출을 이용한 하노이의 탑 문제 해결.
#하노이의 탑: 서로 크기가 다른 n개의 원반과 원반을 끼울 수 있는 기둥이 3개 있다. 어떻게 하면 원반 n개를 모두 1번 기둥에서 3번 기둥으로 옮길 수 있을까?
#제약 1)단, 원반은 한 번에 하나씩만 옮길 수 있다.
#제약 2)각 기둥 맨 위의 원반을 다른 기둥의 맨 위로만 움직여야 한다.
#제약 3)옮기는 과정에서 큰 원반을 작은 원반 위에 올리면 안 된다.

#n개의 원반을 옮기는 하노이의 탑 알고리즘
#1-1. 원반이 1개면 그냥 옮기면 끝(종료조건)
#2. 원반이 n개일 때.
#2-1. 1번 기둥의 n개의 원반 중 n-1개를 2번 기둥으로 옮긴다(3번 기둥을 보조 기둥으로 이용).
#2-2. 1번 기둥에 남아있는 가장 큰 원반을 3번 기둥으로 옮긴다.
#2-3. 2번 기둥에 남아있는 n-1개의 원반을 다시 3번 기둥으로 옮긴다(1번 기둥을 보조 기둥으로 이용).

#재귀 호출을 이용하는 이유: n개의 문제를 풀기 위해 n-1개의 문제를 풀어야 함(좀 더 작은 값으로 자기 자신을 호출하는 과정).

#####################################################################################################################
#하노이의 탑
#입력: 옮기려는 원반의 개수 n
#       옮길 원반이 현재 있는 출발점 기둥 from_pos
#       원반을 옮길 도착점 기둥 to_pos
#       옮기는 과정에서 사용할 보조 기둥 aux_pos
#출력: 원반을 옮기는 순서.
def hanoi(n, from_pos, to_pos, aux_pos):
    if n== 1:                           #원반이 1개일 때는 그냥 옮기면 됨.
        print(from_pos, "->", to_pos)
        return

    hanoi(n-1, from_pos, aux_pos, to_pos) #원반 n-1개를 aux_pos로 이동(to_pos가 보조기둥)
    print(from_pos, "->", to_pos)         #가장 큰 원반을 목적지로 이동
    hanoi(n-1, aux_pos, to_pos, from_pos) #aux_pos에 있는 원반 n-1개를 목적지로 이동(from_pos가 보조기둥)

print("n=1")
hanoi(1, 1, 3, 2) #원반 1개를 1번 기둥에서 3번 기둥으로 이동, 2번 기둥은 보조기둥
print("n=2")
hanoi(2, 1, 3, 2) #원반 2개를 1번 기둥에서 3번 기둥으로 이동, 2번 기둥은 보조기둥
print("n=3")
hanoi(3, 1, 3, 2) #원반 3개를 1번 기둥에서 3번 기둥으로 이동, 2번 기둥은 보조기둥
print("n=10")
hanoi(10, 1, 3, 2)
#####################################################################################################################
#하노이의 탑은 층 수가 높을수록 원반을 더 많이 움직여야 함을 알 수 있다.
#n층짜리 하노이읱 ㅏㅂ을 옮기려면 (2^n)-1번 옮겨야 한다.
#n이 커지면 -1이 의미가 없으므로, 계산복잡도는 O(2^n)으로 표현할 수 있다. n이 커짐에 따라 값이 기하급수적으로 증가한다.

#계산복잡도 표현.
#O(1): n과 무관하게 일정한 시간이 걸림.
#O(n): n과 비례하여 계산 시간이 증가함.
#O(n^2): n의 제곱에 비례하여 계산 시간이 증가함.
#O(2^n): 2의 n제곱에 비례하여 계산 시간이 증가함