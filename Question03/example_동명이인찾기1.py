#동명이인 찾기 알고리즘
#set에 들어있는 n개의 원소에 대해 1:1 비교한다.
#두 번 이상 나온 이름을 찾는다.
#입력: 이름이 n개 들어있는 리스트
#출력: 이름 n개 중 반복되는 이름의 집ㅎ바

#<주의>
#1. 이번에 비교할 이름을 뽑은 다음에는 뽑은 이름보다 순서상 뒤에 있는 이름하고만 비교하면 됨(자기 자신과 비교하는 것은 무의미하고, 앞에 있는 이름과는 이미 비교가 끝났기 때문).
#2. 리스트의 마지막 이름을 기준으로는 비교할 필요 없음. 이미 앞에 있는 이름들과 비교가 끝났음.
#3. 같은 이름을 찾으면 결과 집합에 그 이름을 추가한다.

def find_same_name(x):
    n = len(x)                     #리스트의 자료 개수를 n에 저장
    result = set()                 #결과를 저장할 빈 집합
    for i in range(0, n-1):        #0부터 n-2까지 반복
        for j in range(i+1, n):    #i+1부터 n-1까지 반복
            if x[i] == x[j]:       #이름이 같으면 찾은 이름을 result에 추가.
                result.add(x[i]) 

    return result


name = ["Tom", "Mike", "Jerry", "Tom"]   #대소문자 유의: 파이썬은 대소문자를 구분함.
print(find_same_name(name))
name2 = ["Tom", "Mike", "Jerry", "Tom", "Mike"]   #대소문자 유의: 파이썬은 대소문자를 구분함.
print(find_same_name(name2))


#n개의 이름에 대해 비교하는 위 알고리즘의 계산복잡도를 구해보자.
#   0번째 이름: n-1번 비교(자기를 제외한 모든 이름과 비교).
#   1번째 이름: n-2번 비교(0과 자기를 제외한 모든 이름과 비교).
#   .........
#   n-2번째 위치 이름: 1번 비교
#   n-1번째 위치 이름: 0번 비교
# 총 비교횟수:  0 + 1 + 2 + ... + n-1 = 1 + 2 + 3 + ... + (n-1) = (1+ n-1)(n-1)/2 = n(n-1)/2
# 총 비교횟수가 n(n-1)/2이므로 계산복잡도 = O(n^2). n의 크기에 따라 계산 시간이 비례함을 알 수 있다.